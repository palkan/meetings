<?xml version="1.0" encoding="utf-8"?>
<module:ModuleInstance xmlns:fx="http://ns.adobe.com/mxml/2009"
                           xmlns:s="library://ns.adobe.com/flex/spark"
                           xmlns:components="ru.teachbase.components.*" xmlns:module="ru.teachbase.components.module.*"
                           implements="ru.teachbase.utils.interfaces.ILocalable"
                           creationComplete="init()"
        >
    <fx:Script>
		<![CDATA[
        import caurina.transitions.Tweener;

        import flash.desktop.Clipboard;
        import flash.desktop.ClipboardFormats;

        import mx.collections.ArrayCollection;
        import mx.events.FlexEvent;
        import mx.rpc.Responder;

        import ru.teachbase.constants.NotificationTypes;
        import ru.teachbase.constants.PacketType;
        import ru.teachbase.events.GlobalEvent;
        import ru.teachbase.manage.modules.model.ModuleSettings;
        import ru.teachbase.manage.rtmp.RTMPClient;
        import ru.teachbase.manage.rtmp.RTMPListener;
        import ru.teachbase.manage.rtmp.events.RTMPEvent;
        import ru.teachbase.manage.rtmp.model.Packet;
        import ru.teachbase.manage.rtmp.model.Recipients;
        import ru.teachbase.model.App;
        import ru.teachbase.model.User;
        import ru.teachbase.module.chat.components.ChatElementEvent;
        import ru.teachbase.module.chat.events.ChatEvent;
        import ru.teachbase.module.chat.model.ChatMessage;
        import ru.teachbase.module.chat.model.PrivateChatElement;
        import ru.teachbase.skins.VerticalScrollerBlankSkin;
        import ru.teachbase.skins.VerticalScrollerSkin;
        import ru.teachbase.traits.ChatTrait;
        import ru.teachbase.traits.PrivateChatTrait;
        import ru.teachbase.utils.Localizer;
        import ru.teachbase.utils.helpers.notify;
        import ru.teachbase.utils.shortcuts.rtmp_history;
        import ru.teachbase.utils.shortcuts.rtmp_send;
        import ru.teachbase.utils.shortcuts.style;
        import ru.teachbase.utils.shortcuts.translate;

        private const listener:RTMPListener = new RTMPListener(PacketType.CHAT);

        private var _stopTyperTimer:Timer = new Timer(5000, 1);
        private var _stopListenerTimer:Timer = new Timer(5000, 1);

        [Bindable]
        private var _messagesArray:ArrayCollection = new ArrayCollection;

        [Bindable]
        private var _usersChats:ArrayCollection

        private const user:User = App.user;
        private var _isTyping:Boolean = false;
        private var _rawText:String = "";

        public var setsDP:Vector.<ModuleSettings> = new Vector.<ModuleSettings>();

        private function set showScrollM(value:Boolean):void {
            if (!messagesList || !messagesList.scroller.verticalScrollBar)
                return;

            if (value) {
                messagesList.scroller.verticalScrollBar.setStyle("skinClass", VerticalScrollerSkin);
            } else {
                messagesList.scroller.verticalScrollBar.setStyle("skinClass", VerticalScrollerBlankSkin);
            }
        }

        private function set showScrollC(value:Boolean):void {
            if (!usersList)
                return;
            if (value && usersList.dataGroup.contentHeight > usersList.height) {
                usersList.setStyle('verticalScrollPolicy', "on");
                usersList.scroller.verticalScrollBar.setStyle("skinClass", VerticalScrollerSkin);
            } else {
                usersList.setStyle('verticalScrollPolicy', "off");
            }
        }

        private function init():void {
            label = translate('label', 'chat');
            Localizer.addItem(this);

            GlobalEvent.addEventListener(GlobalEvent.START_PRIVATE_CHAT, globalEventHandler);

            currentState = publicChatState.name;

            if (!_usersChats) {
                _usersChats = new ArrayCollection();
                _usersChats.filterFunction = filterFunction;
            }

            listener.initialize();

            new ChatMessage();
            _stopTyperTimer.addEventListener(TimerEvent.TIMER, onStopType);
            _stopListenerTimer.addEventListener(TimerEvent.TIMER, onStopListenerTimer);

            listener.addEventListener(RTMPEvent.DATA, handleMessage);

            showScrollM = true;
            rtmp_history("chat", new mx.rpc.Responder(historyHandler, null));

            setsDP.push(new ModuleSettings("copy_chat", ModuleSettings.FUN, getRawText));
            setsDP.push(new ModuleSettings("clear_chat", ModuleSettings.FUN, clearChatHandler));

        }

        public function localize():void {
            label = translate('label', 'chat');
        }

        private function onStopType(evt:Event = null):void {
            _stopTyperTimer.reset();
            _isTyping = false;
            var m:ChatMessage
            if (currentState == publicChatState.name) {
                m = new ChatMessage(user.sid, ChatMessage.TYPE_STOPPED, "", "public");
            } else {
                m = new ChatMessage(user.sid, ChatMessage.TYPE_STOPPED, "", String(_curRecipientId));
            }

            __send(m);
        }


        private function __send(m:ChatMessage):void{

            rtmp_send(PacketType.CHAT,m,Recipients.ALL_EXCLUDE_ME,null,false);
        }


        private function typeStarted(evt:TextEvent):void {
                if (evt.text.charCodeAt(0) == 13) {
                    return;
                }

                if (_isTyping) return;

                _stopTyperTimer.reset();
                _stopTyperTimer.start();
                _isTyping = true;
                var m:ChatMessage
                if (currentState == publicChatState.name) {
                    m = new ChatMessage(user.sid, ChatMessage.TYPE_STARTED, "", "public");
                } else {
                    m = new ChatMessage(user.sid, ChatMessage.TYPE_STARTED, "", String(_curRecipientId));
                }

              __send(m);
        }

        private function inputFieldEnterHandler(e:Event):void {

                if (inputField.text == "") {
                    return;
                }

                var m:ChatMessage = new ChatMessage(user.sid, ChatMessage.MESSAGE, user.fullName, inputField.text);
                inputField.text = '';

                if (currentState == publicChatState.name) {
                    rtmp_send(PacketType.CHAT,m,Recipients.ALL,null,false);
                    onStopType();
                } else {
                    m.to = _curRecipientId;
                    rtmp_send(PacketType.CHAT,m,[user.sid, _curRecipientId],null,false);
                }
        }

        private function addPrivateMessage(m:ChatMessage, userId:Number = 0):PrivateChatElement {
            //userId для возможности переопределять комнату. чтобы не создавалась лишняя комната когда отвечаешь

            var pc:PrivateChatElement
            var cid:Number;

            if (m && m.uid === user.sid) {
                m.name = translate('me', 'chat');
                cid = m.to;
            } else if (m) {
                cid = m.uid;
            } else {
                cid = userId;
            }

            if (userId == 0)
                pc = findChat(cid);
            else
                pc = findChat(userId);

            if (m && m.body != "")
                pc.chat.push(m);

            return pc;

        }


        protected function handleMessage(e:RTMPEvent):void{
            const m:ChatMessage = e.packet.data as ChatMessage;

            if(!m) return;

            switch(m.type){

                case ChatMessage.MESSAGE:
                    addMessage(m);
                    break;
                case ChatMessage.TYPE_STARTED:
                case ChatMessage.TYPE_STOPPED:
                case ChatMessage.CLEAR:
                break;
            }

        }

        public function addMessage(m:ChatMessage):void {
            _rawText += m.name + ": \n " + m.body + "\n";

            if (m.uid == user.sid)
                m.name = translate('me', 'chat');

            _messagesArray.addItem(m);

            if (currentState == publicChatState.name) {
                messagesList.addEventListener(FlexEvent.UPDATE_COMPLETE, scrollToSelectedIndexHandler);
                if (messagesList.dataProvider != _messagesArray)
                    messagesList.dataProvider = _messagesArray;
                messagesList.validateNow();
            }
        }

        private function scrollToSelectedIndexHandler(event:FlexEvent = null):void {
            messagesList.removeEventListener(FlexEvent.UPDATE_COMPLETE, scrollToSelectedIndexHandler);

            var spDelta:Point
            if (currentState == publicChatState.name) {
                spDelta = messagesList.dataGroup.layout.getScrollPositionDeltaToElement(_messagesArray.length - 1);
            } else if (_curRecipientId != 0) {
                var pc:PrivateChatElement = findChat(_curRecipientId);
                spDelta = messagesList.dataGroup.layout.getScrollPositionDeltaToElement(pc.chat.length - 1);
            }

            if (!spDelta) return;

            Tweener.addTween(messagesList.layout, {verticalScrollPosition: messagesList.dataGroup.contentHeight, time: 0.5, transition: "easeOutSine"});
        }

        public function clearChatHandler():void {
            rtmp_send(PacketType.CHAT, new ChatMessage(0, ChatMessage.CLEAR), Recipients.ALL);
        }


        public function getRawText():void {

            Clipboard.generalClipboard.setData(ClipboardFormats.TEXT_FORMAT, _rawText);

        }


        private function clearChat(evt:Event = null):void {
            _rawText = "";
            _messagesArray.removeAll();
        }

        private function onPrivateMessage(event:ChatEvent):void {
            const pc:PrivateChatElement = addPrivateMessage(event.message);

            if (currentState == privateChatState.name && (_curRecipientId == event.message.to || _curRecipientId == event.message.uid)) {
                (messagesList.dataProvider as ArrayCollection).refresh();
                messagesList.addEventListener(FlexEvent.UPDATE_COMPLETE, scrollToSelectedIndexHandler);
                messagesList.validateNow();
            } else {
                pc.unreadMessages++;
                newEventsField.text = String(totalUnreaded);
                notify(NotificationTypes.CHAT_NOTIFICATION, event.message.body, App.meeting.usersByID[event.message.uid], true);
            }
        }

        private function onMessage(event:ChatEvent):void {
            if (event.message.type == ChatMessage.MESSAGE) {
                addMessage(event.message);
            } else if (event.message.type == ChatMessage.TYPE_STARTED) {
                var $user:User = App.meeting.usersByID[event.message.uid]
                if ((event.message.body == "public" && currentState == publicChatState.name) || ( currentState == privateChatState.name && Number(event.message.body) == user.sid))
                    typingText.text = translate("writing", "chat", $user.fullName);
                _stopListenerTimer.start();
            } else if (event.message.type == ChatMessage.TYPE_STOPPED) {
                onStopListenerTimer();
            }
        }


        private function onStopListenerTimer(evt:Event = null):void {
            _stopListenerTimer.reset();
            typingText.text = '';
        }

        private function historyHandler(arr:Array):void {
            for each(var p:Packet in arr) {

                var mes:ChatMessage = p.data as ChatMessage;
                if (mes.type == ChatMessage.MESSAGE) {
                    mes.timestampS = p.timeS;
                    addMessage(mes);
                }
            }

            listener.readyToReceive = true;

        }

        override public function get settings():Vector.<ModuleSettings> {

            return setsDP;

        }

        private function roomsBottonClick(event:MouseEvent):void {
            CONFIG::LIVE{
                currentState = usersListState.name;
                label = translate('users', 'users');
                _usersChats.source.sort(compare);
                _usersChats.refresh();
                usersList.addEventListener(ChatElementEvent.CHAT_ELEMET_CLICK, onChatElementClick);
            }
        }

        private function startPrivateChatWithUser(uid:Number):void {
            CONFIG::LIVE{
                _curRecipientId = uid;

                const user:User = App.meeting.usersByID[_curRecipientId];
                label = translate('label', 'chat') + ": " + user.fullName;

                var pc:PrivateChatElement = addPrivateMessage(null, uid);
                pc.unreadMessages = 0;

                newEventsField.text = String(totalUnreaded);

                currentState = privateChatState.name;

                messagesList.dataProvider = new ArrayCollection(pc.chat);
                messagesList.addEventListener(FlexEvent.UPDATE_COMPLETE, scrollToSelectedIndexHandler);
                messagesList.validateNow();

            }
        }

        private function findChat(uid:Number):PrivateChatElement {
            for each(var item:PrivateChatElement in _usersChats.toArray()) {
                if (item.userId == uid)
                    return item;
            }

            var pc:PrivateChatElement = new PrivateChatElement(uid);
            _usersChats.addItem(pc);

            return pc;
        }

        private var _curRecipientId:Number;

        private function onChatElementClick(event:ChatElementEvent):void {
            CONFIG::LIVE{
                startPrivateChatWithUser(event.chatElement.userId);
            }
        }

        private function onPublicChatClick():void {
            CONFIG::LIVE{
                label = translate('label', 'chat');
                _curRecipientId = 0;
                currentState = publicChatState.name;
                messagesList.dataProvider = _messagesArray;
                messagesList.addEventListener(FlexEvent.UPDATE_COMPLETE, scrollToSelectedIndexHandler);
                messagesList.validateNow();
            }
        }

        private function searchInRooms():void {
            _usersChats.refresh();
        }

        private function filterFunction(item:Object):Boolean {
            if (serachField.text == "" || serachField.text == translate('search_field', 'chat'))
                return true;
            if ((item as PrivateChatElement).userName.toLowerCase().indexOf(serachField.text.toLowerCase()) >= 0)
                return true;
            else
                return false;

        }

        private function globalEventHandler(evt:GlobalEvent):void {
            if (evt.type == GlobalEvent.START_PRIVATE_CHAT) {
                startPrivateChatWithUser(Number(evt.value));
            }
        }

        private function get totalUnreaded():int {
            var i:int;
            for each(var item:PrivateChatElement in _usersChats.toArray()) {
                if (item.unreadMessages > 0)
                    i++;
            }

            if (i > 0)
                unreadedShield.visible = true;
            else
                unreadedShield.visible = false;

            return i;
        }

        private function compare(a:PrivateChatElement, b:PrivateChatElement, arr:Array = null):int {

            return (a.unreadMessages > b.unreadMessages) ? -1 : 1;
        }
        ]]>
	</fx:Script>
    <fx:Declarations>
    </fx:Declarations>
    <module:layout>
        <s:VerticalLayout gap="0"/>
    </module:layout>

    <module:states>
        <s:State id="publicChatState" name="publicChatState"/>
        <s:State id="privateChatState" name="privateChatState"/>
        <s:State id="usersListState" name="usersListState"/>
    </module:states>

    <components:CustomSkinableButton id="publicChatButton"
                                     width="100%" height="25"
                                     skinClass="ru.teachbase.module.chat.components.PublicChatButtonSkin"
                                     initialize="with(publicChatButton) {iconUp=style('users','toggleButtonBg'); iconOver=style('users','toggleButtonBg'); iconDown=style('users','toggleButtonBg');label=translate('public_label','chat') }"
                                     click="onPublicChatClick()"
                                     includeIn="usersListState, privateChatState"/>

    <s:List id="messagesList"
            includeIn="publicChatState, privateChatState"
            itemRenderer="ru.teachbase.module.chat.components.ChatMesssageRenderer"
            width="100%" height="100%"
            contentBackgroundAlpha="1"
            horizontalScrollPolicy="off"
            verticalScrollPolicy="on"
            rollOver="showScrollM = true"
            rollOut="showScrollM = false">
        <!--s:initialize>
			<![CDATA[
			if(_messagesArray && currentState == publicChatState.name)
				_messagesArray.refresh();
			]]>
		</s:initialize-->
        <s:layout>
            <s:VerticalLayout gap="0"/>
        </s:layout>
    </s:List>

    <s:List id="usersList"
            includeIn="usersListState"
            itemRenderer="ru.teachbase.module.chat.components.ChatItemRenderer"
            dataProvider="{_usersChats}"
            width="100%" height="100%"
            contentBackgroundAlpha="1"
            useVirtualLayout="false"
            horizontalScrollPolicy="off"
            rollOver="showScrollC = true"
            rollOut="showScrollC = false"
            >
        <s:initialize>
			<![CDATA[
                showScrollC = false;
            ]]>
		</s:initialize>
        <s:layout>
            <s:VerticalLayout gap="0"/>
        </s:layout>
    </s:List>

    <s:Group>
        <s:Label id="typingText" width="100%" color="0xC3C3C4" left="15" bottom="5"/>
    </s:Group>
    <s:Group id="bottomGroup" width="100%" height="46">

        <s:layout>
            <s:BasicLayout/>
        </s:layout>
        <s:Image id="btm_img" initialize="btm_img.source=style('modulecontainer','bottomBackground')" top="0" left="0"
                 right="0" bottom="0" scaleMode="stretch" height="46"/>

        <components:CustomSkinableButton id="roomsView" top="7" left="7"
                                         focusSkin="{null}"
                                         initialize="with(roomsView) {iconUp=style('chat','usersButton'); iconOver=style('chat','usersButton'); iconDown=style('chat','usersButton'); toolTip=translate('rooms_button', 'chat');}"
                                         click="roomsBottonClick(event)"
                                         skinClass="ru.teachbase.skins.CustomSkiningButtonSkin"/>
        <s:Group includeIn="privateChatState, publicChatState" width="100%">
            <s:TextInput id="inputField"
                         color="0xB4B4B4"
                         left="42"
                         right="28"
                         height="30"
                         top="7"
                         width="100%"
                         whiteSpaceCollapse="collapse"
                         initialize="inputField.text = translate('message_field','chat')"
                         skinClass="ru.teachbase.skins.RoundedTextAreaWithBorder"
                         focusSkin="{null}"
                         textInput="typeStarted(event)"
                         enter="inputFieldEnterHandler(event)"
                    >
                <s:click>
					<![CDATA[
                        import ru.teachbase.utils.shortcuts.translate;

                        if (inputField.text == translate('message_field', 'chat')) {
                            inputField.text = "";
                            inputField.setStyle("color", 0x000000);
                        }
                    ]]>
				</s:click>
            </s:TextInput>
            <components:CustomSkinableButton id="sendMessageButton" top="7" right="7"
                                             click="inputFieldEnterHandler(event)" height="30"
                                             initialize="with(sendMessageButton){iconUp=style('chat','sendMessageButton');iconOver=style('chat','sendMessageButton');iconDown=style('chat','sendMessageButton'); toolTip=translate('send_button','chat')}"
                                             skinClass="ru.teachbase.skins.CustomSkiningButtonSkin"/>

        </s:Group>

        <s:Group includeIn="usersListState" width="100%">
            <s:TextInput id="serachField"
                         color="0xB4B4B4"
                         left="42"
                         right="9"
                         height="30"
                         top="7"
                         width="100%"
                         whiteSpaceCollapse="collapse"
                         initialize="serachField.text = translate('search_field','chat')"
                         skinClass="ru.teachbase.skins.RoundedTextAreaWithBorder"
                         focusSkin="{null}"
                         change="searchInRooms()"
                         enter="searchInRooms()"
                    >
                <s:click>
					<![CDATA[
                        import ru.teachbase.utils.shortcuts.translate;

                        if (serachField.text == translate('search_field', 'chat')) {
                            serachField.text = "";
                            serachField.setStyle("color", 0x000000);
                        }
                    ]]>
				</s:click>
            </s:TextInput>
            <components:CustomSkinableButton id="findButton"
                                             top="13" right="15"
                                             click="searchInRooms()"
                                             height="18" width="18"
                                             initialize="with(findButton){iconUp=style('chat','magnifier');iconOver=style('chat','magnifier');iconDown=style('chat','magnifier');}"
                                             skinClass="ru.teachbase.skins.CustomSkiningButtonSkin"/>

        </s:Group>
        <s:Group top="3" left="27" id="unreadedShield" visible="false">
            <s:BitmapImage id="redCircle" source="{style('chat','redCircle')}" right="0"/>
            <s:Label id="newEventsField" text="1" fontSize="11" top="2" color="0xFFFFFF" right="3"/>
        </s:Group>
    </s:Group>
</module:ModuleInstance>
