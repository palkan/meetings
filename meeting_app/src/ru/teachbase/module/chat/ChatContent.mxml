<?xml version="1.0" encoding="utf-8"?>
<module:ModuleInstance xmlns:fx="http://ns.adobe.com/mxml/2009"
                           xmlns:s="library://ns.adobe.com/flex/spark"
                           xmlns:components="ru.teachbase.components.*" xmlns:module="ru.teachbase.components.module.*"
                           xmlns:chat = "ru.teachbase.module.chat.components.*"
                           implements="ru.teachbase.utils.interfaces.ILocalable"
                           creationComplete="creationCompleteHandler()"
        >
    <fx:Script>
		<![CDATA[
        import caurina.transitions.Tweener;

        import flash.desktop.Clipboard;
        import flash.desktop.ClipboardFormats;

        import mx.collections.ArrayCollection;
        import mx.events.FlexEvent;
        import mx.rpc.Responder;

        import ru.teachbase.constants.PacketType;
        import ru.teachbase.events.GlobalEvent;
        import ru.teachbase.manage.modules.model.ModuleSettings;
        import ru.teachbase.manage.rtmp.RTMPListener;
        import ru.teachbase.manage.rtmp.events.RTMPEvent;
        import ru.teachbase.manage.rtmp.model.Packet;
        import ru.teachbase.manage.rtmp.model.Recipients;
        import ru.teachbase.model.App;
        import ru.teachbase.model.User;
        import ru.teachbase.module.chat.components.ChatElementEvent;
        import ru.teachbase.module.chat.model.ChatMessage;
        import ru.teachbase.module.chat.model.PrivateChatElement;
        import ru.teachbase.utils.Localizer;
        import ru.teachbase.utils.shortcuts.$null;
        import ru.teachbase.utils.shortcuts.rtmp_history;
        import ru.teachbase.utils.shortcuts.rtmp_send;
        import ru.teachbase.utils.shortcuts.style;
        import ru.teachbase.utils.shortcuts.translate;

        private const listener:RTMPListener = new RTMPListener(PacketType.CHAT);

        private const TYPING_WAIT_TIME:int = 2000;

        private var _messagesArray:ArrayCollection;
        private var _usersChats:ArrayCollection;

        private const user:User = App.user;

        private var _isTyping:Boolean = false;

        private var _typingID:uint;

        private var _settings:Vector.<ModuleSettings> = new Vector.<ModuleSettings>();

        private var _curRecipientId:Number;


        //------------- initialization / creation------------------//

        private function creationCompleteHandler():void {
            currentState = publicChatState.name;

            new ChatMessage();

            label = translate('label', 'chat');

            Localizer.addItem(this);
            GlobalEvent.addEventListener(GlobalEvent.START_PRIVATE_CHAT, globalEventHandler);

            _usersChats = new ArrayCollection();
            _usersChats.filterFunction = filterUsersByName;

            _messagesArray = new ArrayCollection();

            _settings.push(new ModuleSettings("copy_chat", ModuleSettings.FUN, getRawText));
            _settings.push(new ModuleSettings("clear_chat", ModuleSettings.FUN, clearChatHandler));

            listener.addEventListener(RTMPEvent.DATA, handleMessage);
            listener.initialize();

            rtmp_history(PacketType.CHAT, new mx.rpc.Responder(historyHandler, $null));
        }


        //--------------- handlers --------------------//


        private function typingStopped():void {
            _isTyping = false;
            _typingID = null;
        }


        private function typeStarted(evt:TextEvent):void {
            if (evt.text.charCodeAt(0) == 13) {
                return;
            }

             if (_isTyping) return;

            _isTyping = true;

            _typingID && clearTimeout(_typingID);
            _typingID = setTimeout(typingStopped,TYPING_WAIT_TIME);

            var m:ChatMessage = new ChatMessage(user.sid, ChatMessage.TYPING);

            __send(m);
        }

        private function inputFieldEnterHandler(e:Event):void {

            if (inputField.text == "") {
                return;
            }

            var m:ChatMessage = new ChatMessage(user.sid, ChatMessage.MESSAGE, user.fullName, inputField.text);
            inputField.text = '';

            __send(m);
        }


        protected function handleMessage(e:RTMPEvent):void {
            const m:ChatMessage = e.packet.data as ChatMessage;

            if (!m) return;

            switch (m.type) {
                case ChatMessage.MESSAGE:
                    addMessage(m);
                    break;
                case ChatMessage.TYPING:
                    typingGroup.add(App.meeting.usersByID[m.uid]);
                    break;
                case ChatMessage.CLEAR:
                    break;
            }

        }

        private function scrollToSelectedIndexHandler(event:FlexEvent = null):void {
            messagesList.removeEventListener(FlexEvent.UPDATE_COMPLETE, scrollToSelectedIndexHandler);

            var spDelta:Point
            if (currentState == publicChatState.name) {
                spDelta = messagesList.dataGroup.layout.getScrollPositionDeltaToElement(_messagesArray.length - 1);
            } else if (_curRecipientId != 0) {
                var pc:PrivateChatElement = findChat(_curRecipientId);
                spDelta = messagesList.dataGroup.layout.getScrollPositionDeltaToElement(pc.chat.length - 1);
            }

            if (!spDelta) return;

            Tweener.addTween(messagesList.layout, {verticalScrollPosition: messagesList.dataGroup.contentHeight, time: 0.5, transition: "easeOutSine"});
        }

        public function clearChatHandler():void {
            rtmp_send(PacketType.CHAT, new ChatMessage(0, ChatMessage.CLEAR), Recipients.ALL);
        }

        private function historyHandler(arr:Array):void {
            for each(var p:Packet in arr) {

                var mes:ChatMessage = p.data as ChatMessage;
                if (mes.type == ChatMessage.MESSAGE) {
                    mes.timestampS = p.timeS;
                    addMessage(mes);
                }
            }

            listener.readyToReceive = true;

        }


        private function usersListClick(event:MouseEvent):void {
            currentState = usersListState.name;
            label = translate('users', 'users');
            _usersChats.source.sort(compareUserChats);
            _usersChats.refresh();
            usersList.addEventListener(ChatElementEvent.CHAT_ELEMET_CLICK, onChatElementClick);
        }


        private function onChatElementClick(event:ChatElementEvent):void {
            startPrivateChatWithUser(event.chatElement.userId);
        }

        private function onPublicChatClick():void {
            label = translate('label', 'chat');
            _curRecipientId = 0;
            currentState = publicChatState.name;
            messagesList.dataProvider = _messagesArray;
            messagesList.addEventListener(FlexEvent.UPDATE_COMPLETE, scrollToSelectedIndexHandler);
            messagesList.validateNow();
        }

        //--------------- API ------------------------//


        public function getRawText():void {

            Clipboard.generalClipboard.setData(ClipboardFormats.TEXT_FORMAT, rawText());

        }

        private function clearChat(evt:Event = null):void {
            _messagesArray.removeAll();
        }


        //--------------- controllers -----------------//


        private function rawText():String {
            return null;
        }

        private function __send(m:ChatMessage):void {

            rtmp_send(PacketType.CHAT, m, Recipients.ALL_EXCLUDE_ME, null, false);
        }


        private function addPrivateMessage(m:ChatMessage, userId:Number = 0):PrivateChatElement {
            //userId для возможности переопределять комнату. чтобы не создавалась лишняя комната когда отвечаешь

            var pc:PrivateChatElement
            var cid:Number;

            if (m && m.uid === user.sid) {
                m.name = translate('me', 'chat');
                cid = m.to;
            } else if (m) {
                cid = m.uid;
            } else {
                cid = userId;
            }

            if (userId == 0)
                pc = findChat(cid);
            else
                pc = findChat(userId);

            if (m && m.body != "")
                pc.chat.push(m);

            return pc;

        }


        public function addMessage(m:ChatMessage):void {

            if (m.uid == user.sid)
                m.name = translate('me', 'chat');

            _messagesArray.addItem(m);

            if (currentState == publicChatState.name) {
                messagesList.addEventListener(FlexEvent.UPDATE_COMPLETE, scrollToSelectedIndexHandler);
                if (messagesList.dataProvider != _messagesArray)
                    messagesList.dataProvider = _messagesArray;
                messagesList.validateNow();
            }
        }


        private function startPrivateChatWithUser(uid:Number):void {
            _curRecipientId = uid;

            const user:User = App.meeting.usersByID[_curRecipientId];
            label = translate('label', 'chat') + ": " + user.fullName;

            var pc:PrivateChatElement = addPrivateMessage(null, uid);
            pc.unreadMessages = 0;

            unreadCount.text = String(totalUnread);

            currentState = privateChatState.name;

            messagesList.dataProvider = new ArrayCollection(pc.chat);
            messagesList.addEventListener(FlexEvent.UPDATE_COMPLETE, scrollToSelectedIndexHandler);
            messagesList.validateNow();
        }

        private function findChat(uid:Number):PrivateChatElement {
            for each(var item:PrivateChatElement in _usersChats.toArray()) {
                if (item.userId == uid)
                    return item;
            }

            var pc:PrivateChatElement = new PrivateChatElement(uid);
            _usersChats.addItem(pc);

            return pc;
        }


        private function searchInRooms():void {
            _usersChats.refresh();
        }

        private function filterUsersByName(item:Object):Boolean {
            if (searchField.text == "" || searchField.text == translate('search_field', 'chat'))
                return true;
            if ((item as PrivateChatElement).userName.toLowerCase().indexOf(searchField.text.toLowerCase()) >= 0)
                return true;
            else
                return false;

        }

        private function globalEventHandler(evt:GlobalEvent):void {
            if (evt.type == GlobalEvent.START_PRIVATE_CHAT) {
                startPrivateChatWithUser(Number(evt.value));
            }
        }


        private function compareUserChats(a:PrivateChatElement, b:PrivateChatElement, arr:Array = null):int {

            return (a.unreadMessages > b.unreadMessages) ? -1 : 1;
        }


        public function localize():void {
            label = translate('label', 'chat');
        }


        /* private function onPrivateMessage(event:ChatEvent):void {
         const pc:PrivateChatElement = addPrivateMessage(event.message);

         if (currentState == privateChatState.name && (_curRecipientId == event.message.to || _curRecipientId == event.message.uid)) {
         (messagesList.dataProvider as ArrayCollection).refresh();
         messagesList.addEventListener(FlexEvent.UPDATE_COMPLETE, scrollToSelectedIndexHandler);
         messagesList.validateNow();
         } else {
         pc.unreadMessages++;
         newEventsField.text = String(totalUnreaded);
         notify(NotificationTypes.CHAT_NOTIFICATION, event.message.body, App.meeting.usersByID[event.message.uid], true);
         }
         }

         private function onMessage(event:ChatEvent):void {
         if (event.message.type == ChatMessage.MESSAGE) {
         addMessage(event.message);
         } else if (event.message.type == ChatMessage.TYPE_STARTED) {
         var $user:User = App.meeting.usersByID[event.message.uid]
         if ((event.message.body == "public" && currentState == publicChatState.name) || ( currentState == privateChatState.name && Number(event.message.body) == user.sid))
         typingText.text = translate("writing", "chat", $user.fullName);
         _stopListenerTimer.start();
         } else if (event.message.type == ChatMessage.TYPE_STOPPED) {
         onStopListenerTimer();
         }
         }
         */




        //----------------- get/set -------------------------//


        override public function get settings():Vector.<ModuleSettings> {
            return _settings;
        }


        private function get totalUnread():int {
            var i:int;
            for each(var item:PrivateChatElement in _usersChats.toArray()) {
                if (item.unreadMessages > 0)
                    i++;
            }

            if (i > 0)
                unreadGroup.visible = true;
            else
                unreadGroup.visible = false;

            return i;
        }
        ]]>
	</fx:Script>
    <fx:Declarations>
    </fx:Declarations>



    <module:states>
        <s:State id="publicChatState" name="publicChatState"/>
        <s:State id="privateChatState" name="privateChatState"/>
        <s:State id="usersListState" name="usersListState"/>
    </module:states>

    <s:VGroup gap="0" width="100%" height="100%">
    <components:CustomSkinableButton id="publicChatButton"
                                     width="100%" height="25"
                                     skinClass="ru.teachbase.module.chat.components.PublicChatButtonSkin"
                                     initialize="with(publicChatButton) {iconUp=style('users','toggleButtonBg'); iconOver=style('users','toggleButtonBg'); iconDown=style('users','toggleButtonBg');label=translate('public_label','chat') }"
                                     click="onPublicChatClick()"
                                     includeIn="usersListState, privateChatState"/>

    <components:ScrollList id="messagesList"
            includeIn="publicChatState, privateChatState"
            itemRenderer="ru.teachbase.module.chat.components.ChatMesssageRenderer"
            width="100%" height="100%"
            contentBackgroundAlpha="1"
            horizontalScrollPolicy="off"
            verticalScrollPolicy="on"
      >
        <components:layout>
            <s:VerticalLayout gap="0"/>
        </components:layout>
    </components:ScrollList>

    <components:ScrollList id="usersList"
            includeIn="usersListState"
            itemRenderer="ru.teachbase.module.chat.components.ChatItemRenderer"
            dataProvider="{_usersChats}"
            width="100%" height="100%"
            contentBackgroundAlpha="1"
            useVirtualLayout="false"
            horizontalScrollPolicy="off"
            >
        <components:layout>
            <s:VerticalLayout gap="0"/>
        </components:layout>
    </components:ScrollList>


    <s:Group id="bottomGroup" width="100%" height="46">

        <s:layout>
            <s:BasicLayout/>
        </s:layout>
        <s:Image id="btm_img" initialize="btm_img.source=style('modulecontainer','bottomBackground')" top="0" left="0"
                 right="0" bottom="0" scaleMode="stretch" height="46"/>

        <components:CustomSkinableButton id="roomsView" top="7" left="7"
                                         focusSkin="{null}"
                                         initialize="with(roomsView) {iconUp=style('chat','usersButton'); iconOver=style('chat','usersButton'); iconDown=style('chat','usersButton'); toolTip=translate('rooms_button', 'chat');}"
                                         click="usersListClick(event)"
                                         skinClass="ru.teachbase.skins.CustomSkiningButtonSkin"/>
        <s:Group includeIn="privateChatState, publicChatState" width="100%">
            <s:TextInput id="inputField"
                         color="0xB4B4B4"
                         left="42"
                         right="28"
                         height="30"
                         top="7"
                         width="100%"
                         whiteSpaceCollapse="collapse"
                         initialize="inputField.text = translate('message_field','chat')"
                         skinClass="ru.teachbase.skins.RoundedTextAreaWithBorder"
                         focusSkin="{null}"
                         textInput="typeStarted(event)"
                         enter="inputFieldEnterHandler(event)"
                    >
                <s:click>
					<![CDATA[
                        if (inputField.text == translate('message_field', 'chat')) {
                            inputField.text = "";
                            inputField.setStyle("color", 0x000000);
                        }
                    ]]>
				</s:click>
            </s:TextInput>
            <components:CustomSkinableButton id="sendMessageButton" top="7" right="7"
                                             click="inputFieldEnterHandler(event)" height="30"
                                             initialize="with(sendMessageButton){iconUp=style('chat','sendMessageButton');iconOver=style('chat','sendMessageButton');iconDown=style('chat','sendMessageButton'); toolTip=translate('send_button','chat')}"
                                             skinClass="ru.teachbase.skins.CustomSkiningButtonSkin"/>

        </s:Group>

        <s:Group includeIn="usersListState" width="100%">
            <s:TextInput id="searchField"
                         color="0xB4B4B4"
                         left="42"
                         right="9"
                         height="30"
                         top="7"
                         width="100%"
                         whiteSpaceCollapse="collapse"
                         initialize="searchField.text = translate('search_field','chat')"
                         skinClass="ru.teachbase.skins.RoundedTextAreaWithBorder"
                         focusSkin="{null}"
                         change="searchInRooms()"
                         enter="searchInRooms()"
                    >
                <s:click>
					<![CDATA[
                        if (searchField.text == translate('search_field', 'chat')) {
                            searchField.text = "";
                            searchField.setStyle("color", 0x000000);
                        }
                    ]]>
				</s:click>
            </s:TextInput>
            <components:CustomSkinableButton id="findButton"
                                             top="13" right="15"
                                             click="searchInRooms()"
                                             height="18" width="18"
                                             initialize="with(findButton){iconUp=style('chat','magnifier');iconOver=style('chat','magnifier');iconDown=style('chat','magnifier');}"
                                             skinClass="ru.teachbase.skins.CustomSkiningButtonSkin"/>

        </s:Group>
        <s:Group top="3" left="27" id="unreadGroup" visible="false">
            <s:BitmapImage id="redCircle" source="{style('chat','redCircle')}" right="0"/>
            <s:Label id="unreadCount" text="" fontSize="11" top="2" color="0xFFFFFF" right="3"/>
        </s:Group>
    </s:Group>
    </s:VGroup>

    <chat:TypingBlock bottom="45" width="100%" height="22" id="typingGroup" visible="false">
    </chat:TypingBlock>

</module:ModuleInstance>
