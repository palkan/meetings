<?xml version="1.0" encoding="utf-8"?>
<module:ModuleInstance xmlns:fx="http://ns.adobe.com/mxml/2009"
                           xmlns:s="library://ns.adobe.com/flex/spark"
                           xmlns:components="ru.teachbase.components.*" xmlns:module="ru.teachbase.components.module.*"
                           xmlns:chat = "ru.teachbase.module.chat.components.*"
                           implements="ru.teachbase.utils.interfaces.ILocalable"
                           creationComplete="creationCompleteHandler()"
        >
    <fx:Script>
		<![CDATA[
        import caurina.transitions.Tweener;

        import flash.desktop.Clipboard;
        import flash.desktop.ClipboardFormats;

        import mx.collections.ArrayCollection;
        import mx.events.FlexEvent;
        import mx.rpc.Responder;

        import ru.teachbase.constants.PacketType;
        import ru.teachbase.events.GlobalEvent;
        import ru.teachbase.manage.modules.model.ModuleSettings;
        import ru.teachbase.manage.rtmp.RTMPListener;
        import ru.teachbase.manage.rtmp.events.RTMPEvent;
        import ru.teachbase.manage.rtmp.model.Packet;
        import ru.teachbase.manage.rtmp.model.Recipients;
        import ru.teachbase.manage.session.model.MeetingSettings;
        import ru.teachbase.model.App;
        import ru.teachbase.model.User;
        import ru.teachbase.module.chat.components.ChatElementEvent;
        import ru.teachbase.module.chat.model.ChatMessage;
        import ru.teachbase.module.chat.model.ChatRoom;
        import ru.teachbase.utils.Localizer;
        import ru.teachbase.utils.Permissions;
        import ru.teachbase.utils.shortcuts.$null;
        import ru.teachbase.utils.shortcuts.rtmp_history;
        import ru.teachbase.utils.shortcuts.rtmp_send;
        import ru.teachbase.utils.shortcuts.style;
        import ru.teachbase.utils.shortcuts.translate;

        private const TYPING_WAIT_TIME:int = 2000;

        private const listener:RTMPListener = new RTMPListener(PacketType.CHAT);
        private const user:User = App.user;

        private var _settings:Vector.<ModuleSettings> = new Vector.<ModuleSettings>();


        private var _rooms:ArrayCollection;
        private var _roomsById:Object = {};
        private var _currentRoom:ChatRoom;

        private var _adminsRoom:ChatRoom;

        private var _isTyping:Boolean = false;

        private var _typingID:uint;

        [Bindable]
        private var _privateChatEnabled:Boolean = false;

        private var _initialized:Boolean = false;

        //------------- initialization / creation------------------//

        private function creationCompleteHandler():void {
            currentState = chatState.name;

            new ChatMessage(null, null);

            label = translate('public_label', 'chat');

            Localizer.addItem(this);
            GlobalEvent.addEventListener(GlobalEvent.START_PRIVATE_CHAT, globalEventHandler);

            _rooms = new ArrayCollection();
            _rooms.filterFunction = filterUsersByName;

            // add system rooms

            var publicRoom:ChatRoom = new ChatRoom(Recipients.ALL, translate('public_label', 'chat'), true);
            _roomsById[Recipients.ALL] = publicRoom;
            _rooms.addItem(publicRoom);

            _adminsRoom = new ChatRoom(Recipients.ADMINS, translate('admin_label', 'chat'), true);

            if(App.user.isAdmin()){
                _roomsById[Recipients.ADMINS] = _adminsRoom;
                _rooms.addItem(_adminsRoom);
            }

            _currentRoom = publicRoom;
            _currentRoom.visible = true;
            messagesList.dataProvider = _currentRoom.messages;

            _settings.push(new ModuleSettings("copy_chat", ModuleSettings.FUN, saveAsCSV));//getRawText));
            _settings.push(new ModuleSettings("clear_chat", ModuleSettings.FUN, clearChatHandler));

            listener.addEventListener(RTMPEvent.DATA, handleMessage);
            listener.initialize();

            _privateChatEnabled = App.meeting.settings & MeetingSettings.PRIVATE_CHAT;
            GlobalEvent.addEventListener(GlobalEvent.MEETING_SETTINGS_UPDATE, settingsUpdate);

            rtmp_history(PacketType.CHAT, new mx.rpc.Responder(historyHandler, $null));
        }


        //--------------- handlers --------------------//


        private function settingsUpdate(e:GlobalEvent):void {


            _privateChatEnabled = App.meeting.settings & MeetingSettings.PRIVATE_CHAT;

            if (_privateChatEnabled) return;

            if (currentState != chatState.name) {
                inputField.text = '';
                currentState = chatState.name;
            }

        }

        private function typingStopped():void {
            _isTyping = false;
            _typingID = null;
        }


        private function typeStarted(evt:TextEvent):void {
            if (evt.text.charCodeAt(0) == 13 || !_currentRoom) {
                return;
            }

            if (_isTyping) return;

            _isTyping = true;

            _typingID && clearTimeout(_typingID);
            _typingID = setTimeout(typingStopped, TYPING_WAIT_TIME);

            var m:ChatMessage = new ChatMessage(user.sid, _currentRoom.roomId, ChatMessage.TYPING);

            rtmp_send(PacketType.CHAT, m, _currentRoom.roomId);
        }

        private function inputFieldEnterHandler(e:Event):void {

            if (inputField.text == "") {
                return;
            }

            sendMessage(inputField.text);

            inputField.text = '';
        }


        protected function handleMessage(e:RTMPEvent):void {
            var m:ChatMessage = e.packet.data as ChatMessage;

            if (!m) return;

            // Set server time from packet !important

            m.timestampS = e.packet.timeS;

            switch (m.type) {
                case ChatMessage.MESSAGE:
                    addMessage(m);
                    break;
                case ChatMessage.TYPING:
                    (m.roomId == _currentRoom.roomId) && (m.uid != user.sid) && typingGroup.add(App.meeting.usersByID[m.uid]);
                    break;
                case ChatMessage.CLEAR:
                    clearChat(m.roomId);
                    break;
            }

        }


        private function historyHandler(arr:Array):void {

            for each(var p:Packet in arr) {

                var mes:ChatMessage = p.data as ChatMessage;
                if (mes.type == ChatMessage.MESSAGE) {
                    mes.timestampS = p.timeS;
                    addMessage(mes);
                }
            }

            listener.readyToReceive = true;

            _initialized = true;

        }

        private function scrollToSelectedIndexHandler(event:FlexEvent = null):void {

            messagesList.removeEventListener(FlexEvent.UPDATE_COMPLETE, scrollToSelectedIndexHandler);

            if (!_currentRoom) return;

            var spDelta:Point = messagesList.dataGroup.layout.getScrollPositionDeltaToElement(_currentRoom.all().length - 1);
            if (!spDelta) return;

            Tweener.addTween(messagesList.layout, {verticalScrollPosition: messagesList.dataGroup.contentHeight, time: 0.5, transition: "easeOutSine"});
        }


        public function clearChatHandler():void {
            if (_currentRoom) return;
            rtmp_send(PacketType.CHAT, new ChatMessage(user.sid, _currentRoom.roomId, ChatMessage.CLEAR), _currentRoom.roomId);
        }

        private function roomsListClick(event:MouseEvent):void {
            currentState = roomsState.name;
            label = translate('users', 'users');
            _rooms.source.sort(compareChatRooms);
            _rooms.refresh();
            roomsList.addEventListener(ChatElementEvent.CHAT_ELEMENT_CLICK, onChatElementClick);
        }

        private function onChatElementClick(event:ChatElementEvent):void {
            switchChatRoom(event.chatElement.roomId);
        }


        //--------------- API ------------------------//


        public function getRawText():void {
            Clipboard.generalClipboard.setData(ClipboardFormats.TEXT_FORMAT, rawText());
        }


        public function saveAsCSV():void{

            if (!_currentRoom) return;

            const messagesToStr:Array = _currentRoom.all().source.map(function (mes:ChatMessage, ind:int, arr:Array):String {
                return mes.toCSVString();
            });

            const data:String = messagesToStr.join("\n");

            var fileReference:FileReference = new FileReference();
            fileReference.save(data, "chat_log.csv");

        }

        //--------------- controllers -----------------//


        private function clearChat(roomId:Number):void {
            if (!_roomsById[roomId]) return;

            const room:ChatRoom = _roomsById[roomId] as ChatRoom;

            room.clear();
        }


        private function sendMessage(body:String):void {

            if (!_currentRoom) return;

            var m:ChatMessage = new ChatMessage(user.sid, _currentRoom.roomId, ChatMessage.MESSAGE, user.fullName, body);

            rtmp_send(PacketType.CHAT, m, _currentRoom.roomId);   // roomId is equal to Recipients code or user's sid
        }


        private function rawText():String {
            if (!_currentRoom) return '';

            const messagesToStr:Array = _currentRoom.all().source.map(function (mes:ChatMessage, ind:int, arr:Array):String {
                return mes.toString();
            });

            return messagesToStr.join("\n");
        }


        public function addMessage(m:ChatMessage):void {

            if (m.uid == user.sid)
                m.name = translate('me', 'chat');

            if (!_roomsById[m.roomId]) addRoom(m.roomId, m.name);   // create private chat with user (so message name == user.fullName)

            (_roomsById[m.roomId] as ChatRoom).add(m);

            if (_currentRoom.roomId == m.roomId && currentState == chatState.name) {
                messagesList.addEventListener(FlexEvent.UPDATE_COMPLETE, scrollToSelectedIndexHandler);
                messagesList.validateNow();
            }
        }

        private function addRoom(id:Number, name:String):void {

            var room:ChatRoom = new ChatRoom(id, name);

            _roomsById[room.roomId] = room;
            _rooms.addItem(room);

        }

        private function switchChatRoom(id:Number):void {

            const user:User = App.meeting.usersByID[id];

            if (!_roomsById[id] && !user) return;

            if (!_roomsById[id]) addRoom(id, user.fullName);

            _currentRoom.visible = false;

            _currentRoom = _roomsById[id];

            _currentRoom.visible = true;

            label = translate('label', 'chat') + ": " + _currentRoom.roomName;

            messagesList.dataProvider = _currentRoom.messages;

            currentState = chatState.name;
        }


        private function searchInRooms():void {
            _rooms.refresh();
        }

        private function filterUsersByName(item:Object):Boolean {
            if (searchField.text == "" || searchField.text == translate('search_field', 'chat'))
                return true;
            if ((item as ChatRoom).roomName.toLowerCase().indexOf(searchField.text.toLowerCase()) >= 0)
                return true;
            else
                return false;

        }

        private function globalEventHandler(evt:GlobalEvent):void {
            if (evt.type == GlobalEvent.START_PRIVATE_CHAT) {
                switchChatRoom(Number(evt.value));
            }
        }


        private function compareChatRooms(a:ChatRoom, b:ChatRoom, arr:Array = null):int {

            if (a.system && !b.system) return  -1;

            if (a.system && b.system) return a.roomId > b.roomId ? -1 : 1;

            if (a.unreadMessages == b.unreadMessages) return 0;

            return (a.unreadMessages > b.unreadMessages) ? -1 : 1;
        }


        public function localize():void {
            label = translate('label', 'chat');
        }


        //----------------- get/set -------------------------//


        override public function set permissions(value:uint):void {
            super.permissions = value;

            if(!_initialized) return;

            if(!Permissions.isAdmin(value)){

                if(!_roomsById[_adminsRoom.roomId]) return;

                if(_currentRoom.roomId == _adminsRoom.roomId) switchChatRoom(Recipients.ALL);

                delete _roomsById[_adminsRoom.roomId];

                _rooms.removeItemAt(_rooms.getItemIndex(_adminsRoom));

            }else{

                if(_roomsById[_adminsRoom.roomId]) return;

                _roomsById[_adminsRoom.roomId] = _adminsRoom;

                _rooms.addItem(_adminsRoom);

            }

        }

        override public function get settings():Vector.<ModuleSettings> {
            return _settings;
        }


        private function get totalUnread():int {
            var i:int = 0;
            for each(var item:ChatRoom in _rooms.toArray()) {
                if (item.unreadMessages > 0)
                    i++;
            }

            if (i > 0)
                unreadGroup.visible = true;
            else
                unreadGroup.visible = false;

            return i;
        }
        ]]>
	</fx:Script>
    <fx:Declarations>
    </fx:Declarations>



    <module:states>
        <s:State id="chatState" name="chat"/>
        <s:State id="roomsState" name="roomsList"/>
    </module:states>

    <s:VGroup gap="0" width="100%" height="100%">
    <!--components:CustomSkinableButton id="publicChatButton"
                                     width="100%" height="25"
                                     skinClass="ru.teachbase.module.chat.components.PublicChatButtonSkin"
                                     initialize="with(publicChatButton) {iconUp=style('users','toggleButtonBg'); iconOver=style('users','toggleButtonBg'); iconDown=style('users','toggleButtonBg');label=translate('public_label','chat') }"
                                     click="onPublicChatClick()"
                                     includeIn="roomsList, private"/-->

    <components:ScrollList id="messagesList"
            includeIn="chat"
            itemRenderer="ru.teachbase.module.chat.components.ChatMesssageRenderer"
            width="100%" height="100%"
            contentBackgroundAlpha="1"
            horizontalScrollPolicy="off"
            verticalScrollPolicy="on"
      >
        <components:layout>
            <s:VerticalLayout gap="0"/>
        </components:layout>
    </components:ScrollList>

    <components:ScrollList id="roomsList"
            includeIn="roomsList"
            itemRenderer="ru.teachbase.module.chat.components.ChatItemRenderer"
            dataProvider="{_rooms}"
            width="100%" height="100%"
            contentBackgroundAlpha="1"
            useVirtualLayout="false"
            horizontalScrollPolicy="off"
            verticalScrollPolicy="auto"
            >
        <components:layout>
            <s:VerticalLayout gap="0"/>
        </components:layout>
    </components:ScrollList>


    <s:Group id="bottomGroup" width="100%" height="46">

        <s:layout>
            <s:BasicLayout/>
        </s:layout>
        <s:Image id="btm_img" initialize="btm_img.source=style('modulecontainer','bottomBackground')" top="0" left="0"
                 right="0" bottom="0" scaleMode="stretch" height="46"/>
        <s:HGroup gap="0" width="100%" height="100%">
        <s:Group>
        <components:CustomSkinableButton id="roomsView" top="7" left="7"
                                         includeInLayout="{_privateChatEnabled}"
                                         visible="{_privateChatEnabled}"
                                         focusSkin="{null}"
                                         initialize="with(roomsView) {iconUp=style('chat','usersButton'); iconOver=style('chat','usersButton'); iconDown=style('chat','usersButton'); toolTip=translate('rooms_button', 'chat');}"
                                         click="roomsListClick(event)"
                                         skinClass="ru.teachbase.skins.CustomSkiningButtonSkin"/>
        </s:Group>
        <s:Group includeIn="chat" width="100%">
            <s:TextInput id="inputField"
                         color="0xB4B4B4"
                         left="7"
                         right="28"
                         height="30"
                         top="7"
                         width="100%"
                         whiteSpaceCollapse="collapse"
                         initialize="inputField.text = translate('message_field','chat')"
                         skinClass="ru.teachbase.skins.RoundedTextAreaWithBorder"
                         focusSkin="{null}"
                         textInput="typeStarted(event)"
                         enter="inputFieldEnterHandler(event)"
                    >
                <s:click>
					<![CDATA[
                        if (inputField.text == translate('message_field', 'chat')) {
                            inputField.text = "";
                            inputField.setStyle("color", 0x000000);
                        }
                    ]]>
				</s:click>
            </s:TextInput>
            <components:CustomSkinableButton id="sendMessageButton" top="7" right="7"
                                             click="inputFieldEnterHandler(event)" height="30"
                                             initialize="with(sendMessageButton){iconUp=style('chat','sendMessageButton');iconOver=style('chat','sendMessageButton');iconDown=style('chat','sendMessageButton'); toolTip=translate('send_button','chat')}"
                                             skinClass="ru.teachbase.skins.CustomSkiningButtonSkin"/>

        </s:Group>
        </s:HGroup>
        <s:Group includeIn="roomsList" width="100%">
            <s:TextInput id="searchField"
                         color="0xB4B4B4"
                         left="42"
                         right="9"
                         height="30"
                         top="7"
                         width="100%"
                         whiteSpaceCollapse="collapse"
                         initialize="searchField.text = translate('search_field','chat')"
                         skinClass="ru.teachbase.skins.RoundedTextAreaWithBorder"
                         focusSkin="{null}"
                         change="searchInRooms()"
                         enter="searchInRooms()"
                    >
                <s:click>
					<![CDATA[
                        if (searchField.text == translate('search_field', 'chat')) {
                            searchField.text = "";
                            searchField.setStyle("color", 0x000000);
                        }
                    ]]>
				</s:click>
            </s:TextInput>
            <components:CustomSkinableButton id="findButton"
                                             top="13" right="15"
                                             click="searchInRooms()"
                                             height="18" width="18"
                                             initialize="with(findButton){iconUp=style('chat','magnifier');iconOver=style('chat','magnifier');iconDown=style('chat','magnifier');}"
                                             skinClass="ru.teachbase.skins.CustomSkiningButtonSkin"/>

        </s:Group>
        <s:Group top="3" left="27" id="unreadGroup" visible="false">
            <s:BitmapImage id="redCircle" source="{style('chat','redCircle')}" right="0"/>
            <s:Label id="unreadCount" text="" fontSize="11" top="2" color="0xFFFFFF" right="3"/>
        </s:Group>
    </s:Group>
    </s:VGroup>

    <chat:TypingBlock bottom="45" width="100%" height="22" id="typingGroup" visible="false">
    </chat:TypingBlock>

</module:ModuleInstance>
