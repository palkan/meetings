<?xml version="1.0" encoding="utf-8"?>
<module:ModuleInstance xmlns:fx="http://ns.adobe.com/mxml/2009"
                       xmlns:s="library://ns.adobe.com/flex/spark"
                       xmlns:components="ru.teachbase.components.*"
                       xmlns:layout="ru.teachbase.layout.*" xmlns:module="ru.teachbase.components.module.*"
                       implements="ru.teachbase.utils.interfaces.ILocalable"
                       creationComplete="creationCompleteHandler(event)" addedToStage="addedToStage(event)">
    <fx:Script>
		<![CDATA[
        import mx.events.FlexEvent;

        import ru.teachbase.events.CameraEvent;
        import ru.teachbase.events.LocalStreamEvent;
        import ru.teachbase.manage.PublishManager;
        import ru.teachbase.manage.StreamManager;
        import ru.teachbase.manage.TraitManager;
        import ru.teachbase.model.LocalStream;
        import ru.teachbase.module.video.components.IVideoContainer;
        import ru.teachbase.traits.CameraTrait;
        import ru.teachbase.traits.LocalStreamTrait;
        import ru.teachbase.traits.Trait;
        import ru.teachbase.utils.Localizer;
        import ru.teachbase.utils.Permissions;
        import ru.teachbase.utils.helpers.*;
        import ru.teachbase.utils.helpers.skin;
        import ru.teachbase.utils.shortcuts.style;
        import ru.teachbase.utils.shortcuts.translate;
        import ru.teachbase.utils.shortcuts.translate;

        CONFIG::LIVE{
            import ru.teachbase.module.video.components.VideoContainer;
        }

        CONFIG::RECORDING{
            import ru.teachbase.module.video.components.VideoContainerRecord;
        }
        private var _cameraTrait:Trait = TraitManager.instance.createTrait(CameraTrait) as CameraTrait;
        private var _streamTrait:Trait = TraitManager.instance.createTrait(LocalStreamTrait) as LocalStreamTrait;

        private var elements:Vector.<IVideoContainer> = new Vector.<IVideoContainer>;

        [Bindable]
        private var _camVideoContainerInstance:IVideoContainer;

        [Bindable]
        private var _streams:int;

        [Bindable]
        private var _editable:Boolean;


        private function addedToStage(evt:Event):void {
            CONFIG::LIVE{
                (m(PublishManager) as PublishManager).enable();
            }
        }

        private function creationCompleteHandler(event:FlexEvent):void {

            CONFIG::LIVE{
                _cameraTrait.addEventListener(CameraEvent.CAMERA_CHANGED, onCameraChangeEvent);
                _cameraTrait.addEventListener(CameraEvent.CAMERA_END, cameraEndEvent);
            }

            _streamTrait.addEventListener(LocalStreamEvent.VIDEO_CHANGED, onStreamChangeEvent);

            label = translate('label', 'video');

            Localizer.addItem(this);

            for each (var str:LocalStream in (m(StreamManager) as StreamManager).videoStreams)
                addVideo(str.stream, str.userId);

        }

        CONFIG::LIVE{

            private function onCameraChangeEvent(evt:CameraEvent):void {
                if (evt.camera) {
                    addCamera(evt.camera);
                }
            }

            private function cameraEndEvent(event:CameraEvent):void {
                removeCamera();
            }

        }

        private function onStreamChangeEvent(evt:LocalStreamEvent):void {
            if (evt.stream.stream && getVideoContainer(evt.stream.userId) == null) {
                addVideo(evt.stream.stream, evt.stream.userId);
                if (evt.stream.rotation)
                    getVideoContainer(evt.stream.userId).rotateVideo(evt.stream.rotation);
            }

            if (!evt.stream.stream && getVideoContainer(evt.stream.userId)) {
                removeVideo(getVideoContainer(evt.stream.userId));
            }

            if (evt.stream.stream && getVideoContainer(evt.stream.userId)) {
                getVideoContainer(evt.stream.userId).rotateVideo(evt.stream.rotation);
            }

        }

        private function getVideoContainer(userId:Number):IVideoContainer {
            for each (var vc:IVideoContainer in elements) {
                if (vc.from == userId) {
                    return vc;
                }
            }
            return null;
        }


        private function addVideo(ns:NetStream = null, userId:Number = 0):void {
            CONFIG::LIVE{
                var vc:VideoContainer = new VideoContainer();
            }

            CONFIG::RECORDING{

                var vc:VideoContainerRecord = new VideoContainerRecord();
            }

            vc.stream = ns;
            vc.from = userId;
            vc.isAdmin = Permissions.isAdmin(permission);
            vc.addEventListener("removeStream", onRemoveStream);
            vc.addEventListener("removeUserStream", onRemoveUserStream);// убивает поток
            vc.addEventListener("removeVideo", onRemoveVideo); // при переключении в аудио режим, не убивает поток
            elements.push(vc);
            videoCont.addElement(vc);
            _streams++;
        }

        CONFIG::LIVE{
            private function addCamera(cam:Camera):void {
                if (_camVideoContainerInstance == null) {
                    _camVideoContainerInstance = new VideoContainer();
                    _camVideoContainerInstance.isAdmin = true;
                    _camVideoContainerInstance.addEventListener("removeStream", onRemoveStream);
                    elements.push(_camVideoContainerInstance);
                    _camVideoContainerInstance.camera = cam;
                    videoCont.addElement(_camVideoContainerInstance);


                } else {
                    _camVideoContainerInstance.camera = cam;
                }
            }

        }
        private function removeVideo(vc:IVideoContainer):void {
            elements.splice(elements.indexOf(vc), 1);
            if (vc.stage)
                videoCont.removeElement(vc);
            vc = null;
            _streams--;
        }

        CONFIG::LIVE{
            private function removeCamera():void {
                if (_camVideoContainerInstance != null) {
                    elements.splice(elements.indexOf(_camVideoContainerInstance), 1);
                    videoCont.removeElement(_camVideoContainerInstance);
                    _camVideoContainerInstance.camera = null;
                    _camVideoContainerInstance = null;
                }
            }

        }
        private function onRemoveStream(event:Event):void {
            const vc:IVideoContainer = event.target as IVideoContainer

            removeVideoContainer(vc);
        }


        private function onRemoveUserStream(event:Event):void {
            const vc:IVideoContainer = event.target as IVideoContainer
            if (!vc.camera) {
                (m(StreamManager) as StreamManager).closeUserStream(vc.from);
            }
            removeVideoContainer(vc);
        }

        private function onRemoveVideo(event:Event):void {
            const vc:IVideoContainer = event.target as IVideoContainer;
            removeVideoContainer(vc);
        }

        private function removeVideoContainer(vc:IVideoContainer):void {
            if (!vc.camera) {
                removeVideo(vc as IVideoContainer);
            } else {
                CONFIG::LIVE{
                    (m(PublishManager) as PublishManager).closeCamera();
                }
            }
        }

        override public function hideContainer():void {
            super.hideContainer();
            CONFIG::LIVE{
                (m(PublishManager) as PublishManager).disable();
            }
            for each(var el:IVideoContainer in elements) {
                removeVideoContainer(el);
            }
        }


        public function localize():void {
            label = translate('label', 'video');
            bottomButton && (bottomButton.label = translate('turn_on_cam', 'settings'));
            bigBlbl && (bigBlbl.text = translate('turn_on_cam', 'settings'));
        }


        override public function set permission(value:int):void {
            editable = Permissions.camAvailable(value);

            for each(var el:IVideoContainer in elements)
                el.isAdmin = Permissions.isAdmin(value);


            super.permission = value;
        }


        public function set editable(value:Boolean):void {
            CONFIG::LIVE{
                if (!value) {
                    (m(PublishManager) as PublishManager).closeCamera();
                }
            }
            _editable = value;
        }

        public function get editable():Boolean {
            return _editable;
        }
        ]]>
	</fx:Script>

    <s:Group id="videoCont" width="100%" height="100%">
        <s:layout>
            <layout:VideoLayout ratio="0.75"/>
        </s:layout>
    </s:Group>
    <s:VGroup horizontalCenter="0" verticalCenter="0"
              visible="{_camVideoContainerInstance == null &amp;&amp; _streams == 0 &amp;&amp; _editable}">
        <components:CustomSkinableButton id="bigButton"
                                         initialize="with(bigButton){iconUp=ru.teachbase.utils.helpers.style('video','bigCameraButton');iconDown=ru.teachbase.utils.helpers.style('video','bigCameraButtonDown');iconOver=ru.teachbase.utils.helpers.style('video','bigCameraButtonHover');}"
                                         skinClass="ru.teachbase.skins.CustomSkiningButtonSkin" focusSkin="{null}">
            <components:click>
				<![CDATA[
                    import ru.teachbase.manage.PublishManager;
                    import ru.teachbase.manage.PublishManager;

                    CONFIG::LIVE{

                        (m(PublishManager) as PublishManager).toggleStartCamera();


                    }
                ]]>
			</components:click>
        </components:CustomSkinableButton>
        <s:Label id="bigBlbl" initialize="bigBlbl.text=translate('turn_on_cam','settings')" textAlign="center"
                 width="100%" color="0x8196A6"/>
    </s:VGroup>
    <s:Group width="100%" bottom="0" left="0" right="0"
             visible="{_camVideoContainerInstance == null &amp;&amp; _streams > 0 &amp;&amp; _editable}"
             show="videoCont.bottom = 46" hide="videoCont.bottom = 0">
        <s:layout>
            <s:BasicLayout/>
        </s:layout>
        <s:Image source="{style('modulecontainer','bottomBackground')}" top="0" left="0" right="0" bottom="0"
                 scaleMode="stretch" height="46"/>
        <components:CustomSkinableButton horizontalCenter="0" bottom="6" id="bottomButton"
                                         initialize="with(bottomButton){label=translate('turn_on_cam','settings');iconUp=ru.teachbase.utils.helpers.style('video','bottomCameraButton');iconDown=ru.teachbase.utils.helpers.style('video','bottomCameraButtonDown');iconOver=ru.teachbase.utils.helpers.style('video','bottomCameraButtonHover');}"
                                         skinClass="ru.teachbase.skins.StandartButtonWithIcon">
            <components:click>
				<![CDATA[
                    import ru.teachbase.manage.PublishManager;
                    import ru.teachbase.manage.PublishManager;

                    CONFIG::LIVE{

                        (m(PublishManager) as PublishManager).toggleStartCamera();


                    }
                ]]>
			</components:click>
        </components:CustomSkinableButton>
    </s:Group>
</module:ModuleInstance>
