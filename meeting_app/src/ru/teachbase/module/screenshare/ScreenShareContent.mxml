<?xml version="1.0" encoding="utf-8"?>
<module:ModuleInstance xmlns:fx="http://ns.adobe.com/mxml/2009"
                       xmlns:s="library://ns.adobe.com/flex/spark"
                       xmlns:components="ru.teachbase.components.*" xmlns:module="ru.teachbase.components.module.*"
                       xmlns:mx="library://ns.adobe.com/flex/mx"
                       implements="ru.teachbase.utils.interfaces.ILocalable"
                       creationComplete="creationCompleteHandler(event)">
    <module:states>
        <s:State id="sharing" name="sharing"/>
        <s:State id="iams" name="iamsharing"/>
        <s:State id="iamp" name="iampreparing"/>
        <s:State id="prepare" name="prepare"/>
        <s:State id="prepare_ext" name="prepare_ext"/>
        <s:State id="iamext" name="iamexternal"/>
        <s:State id="idle" name="idle"/>
    </module:states>
    <fx:Script>
		<![CDATA[
        import mx.events.CollectionEvent;
        import mx.events.CollectionEventKind;
        import mx.events.FlexEvent;
        import mx.rpc.Responder;

        import ru.teachbase.components.callouts.SettingsItem;
        import ru.teachbase.constants.PacketType;
        import ru.teachbase.events.GlobalEvent;
        import ru.teachbase.manage.rtmp.RTMPListener;
        import ru.teachbase.manage.rtmp.events.RTMPEvent;
        import ru.teachbase.manage.rtmp.model.Recipients;
        import ru.teachbase.manage.streams.model.NetStreamClient;
        import ru.teachbase.manage.streams.model.StreamType;
        import ru.teachbase.model.App;
        import ru.teachbase.model.User;
        import ru.teachbase.module.screenshare.components.VideoContainerShare;
        import ru.teachbase.utils.BrowserUtils;
        import ru.teachbase.utils.Localizer;
        import ru.teachbase.utils.Permissions;
        import ru.teachbase.utils.shortcuts.*;

        private const listener:RTMPListener = new RTMPListener(PacketType.SCREEN_SHARING);

        private var _activeUser:User;

        private const user:User = App.user;

        private var _settings:Vector.<SettingsItem> = new Vector.<SettingsItem>();

        private var _netStream:NetStream;

        private var _vc:VideoContainerShare;

        private var _sizeInited:Boolean = false;

        private var _sizeId:uint;

        [Bindable]
        private var _p_enabled:Boolean = false;

        [Bindable]
        private var _app_available:Boolean = false;

        [Bindable]
        private var _external:Boolean = false;

        [Bindable]
        private var _external_path:String = '';

        [Bindable]
        private var _external_name:String = '';


        override public function init():void {
            listener.initialize();
            listener.addEventListener(RTMPEvent.DATA, handleMessage);
        }


        private function creationCompleteHandler(event:FlexEvent):void {

            currentState = idle.name;

            _settings.push(new SettingsItem("clear_screen_share", SettingsItem.FUN, stopShare));

            label = translate('label', 'screenshare');

            Localizer.addItem(this);

            _p_enabled = Permissions.docsAvailable(App.user.permissions);

            App.meeting.streamList.addEventListener(CollectionEvent.COLLECTION_CHANGE, onStreamChangeEvent);

            GlobalEvent.addEventListener(GlobalEvent.RECONNECT, handleReconnect);
            GlobalEvent.addEventListener(GlobalEvent.RESET, handleReset);
            GlobalEvent.addEventListener(GlobalEvent.USER_LEAVE, handleUserLeave);

            var share_streams:Array = App.meeting.streamList.toArray().filter(filter);

            if (share_streams.length) {

                const ns:NetStream = share_streams[0];

                _activeUser = App.meeting.usersByID[(ns.client as NetStreamClient).data.user_id];

                currentState = prepare.name;
                addStream(ns);

                listener.readyToReceive = true;
                _initialized = true;
            } else
                rtmp_history(PacketType.SCREEN_SHARING, new mx.rpc.Responder(handleHistory, $null));
        }


        private function handleUserLeave(e:GlobalEvent):void {
            if (_activeUser && _activeUser.sid == e.value.sid) dispose();
        }


        private function handleHistory(data:Object):void {

            data && processData(data);

            listener.readyToReceive = true;

            _initialized = true;

        }


        private function handleReset(e:GlobalEvent):void {

            dispose();

            listener.dispose();
            listener.initialize();


            App.meeting.streamList.removeEventListener(CollectionEvent.COLLECTION_CHANGE, onStreamChangeEvent);

        }


        private function handleReconnect(e:GlobalEvent):void {

            dispose();

            listener.dispose();
            listener.initialize();

            _p_enabled = Permissions.docsAvailable(App.user.permissions);

            App.meeting.streamList.addEventListener(CollectionEvent.COLLECTION_CHANGE, onStreamChangeEvent);

            var share_streams:Array = App.meeting.streamList.toArray().filter(filter);

            if (share_streams.length) {

                //todo: dry this!
                const ns:NetStream = share_streams[0];
                currentState = prepare.name;
                _activeUser = App.meeting.usersByID[(ns.client as NetStreamClient).data.user_id];

                addStream(ns);
                listener.readyToReceive = true;
                _initialized = true;
            } else
                rtmp_history(PacketType.SCREEN_SHARING, new mx.rpc.Responder(handleHistory, $null));


        }

        private function onStreamChangeEvent(e:CollectionEvent):void {

            switch (e.kind) {
                case CollectionEventKind.REMOVE:
                {
                    for each(var ns:NetStream in e.items) {
                        (_netStream === ns) && dispose();
                    }
                    break;
                }
                case CollectionEventKind.ADD:
                {
                    var share_streams:Array = e.items.filter(filter);

                    share_streams.length && addStream(share_streams[0]);
                    break;
                }
                case CollectionEventKind.UPDATE:
                {
                    break;
                }
                case CollectionEventKind.RESET:
                {
                    dispose();
                    break;
                }
            }
        }


        private function filter(stream:NetStream, index:int = 0, arr:Array = null):Boolean {
            return Boolean(stream && (stream.client as NetStreamClient) && ((stream.client as NetStreamClient).data.type != StreamType.MEDIA));
        }


        private function handleMessage(e:RTMPEvent):void {

            const data:Object = e.packet.data;
            processData(data);
        }

        private function processData(data:Object):void {
            if (data && data.type === "prepare" && data.uid) {
                prepareShare(data.uid);
            } else if (data && data.type === "stop") {
                dispose();
            } else if (data && data.type === "start" && data.uid == user.sid) {
                if(data.stream_type == "external"){
                    _external = true;
                    statusText.text = translate("external_me", "screenshare");
                    currentState = iamext.name;
                }else{
                    currentState = iams.name;
                }
            }

        }


        private function prepareShare(uid:Number):void {

            _activeUser = App.meeting.usersByID[uid];

            if (!_activeUser) return;

            if (user.sid === uid) {

                currentState = iamp.name;

                statusText.text = translate("prepare_me", "screenshare");

            } else {

                currentState = prepare.name;

                statusText.text = translate("prepare", "screenshare", _activeUser.fullName);

            }

        }


        private function startExternal():void {

            function success(data:Object) {
                debug(data.path, data.name);
                _external_path = build_host_path(data.path);
                _external_name = data.name;
                prepareExternal();
            }

            rtmp_call("request_external", new mx.rpc.Responder(success, $null));
        }


        private function prepareExternal():void{
            currentState = prepare_ext.name;
            rtmp_send(PacketType.SCREEN_SHARING, {type: "prepare", uid: App.user.sid}, Recipients.ALL_EXCLUDE_ME);
        }

        private function stopShare():void {
            if(_external){
                rtmp_call("close_external");
            }else{
                BrowserUtils.sendCall("exCall", "stop");
                rtmp_send(PacketType.SCREEN_SHARING, {type: "stop", uid: App.user.sid});
            }
        }


        private function addStream(stream:NetStream):void {

            if (_netStream) {
                warning("Stream already exists: " + (_netStream.client as NetStreamClient).data.name);
                return;
            }

            _netStream = stream;

            if (!_activeUser) {

                if ((_netStream.client as NetStreamClient) && (_netStream.client as NetStreamClient).data)
                    _activeUser = App.meeting.usersByID[(_netStream.client as NetStreamClient).data.user_id];


                if (!_activeUser) {
                    warning("No active user!");
                    return;
                }
            }

            label = translate('label', 'screenshare') + " — " + _activeUser.fullName;


            _external = (_netStream.client as NetStreamClient).data.type === StreamType.EXTERNAL;

            _netStream.client.onMouseData = function (metadata:Object):void {
                if (!metadata)
                    return;

                if (metadata.msgtype && metadata.msgtype == "mouse") {
                    _vc && _vc.toggleCursor(new Point(metadata.posx, metadata.posy));
                }

            };

            _sizeId = setInterval(setVideoSize, 100);

            currentState = sharing.name;

            _vc = new VideoContainerShare();

            _vc.stream = _netStream;
            _vc.from = _activeUser.sid;

            _vc.percentHeight = 100;
            _vc.percentWidth = 100;

            addElement(_vc);
        }

        protected function build_host_path(path:String):String{
            var rxp:RegExp = /^rtmps?\:\/\/[^\/]+/;
            var host:String = rxp.exec(config("net/rtmp"));
            return host + "/" + path;
        }

        override public function hide():void {
            super.hide();
            dispose();
        }

        public function dispose():void {

            _netStream = null;

            if (_vc) {
                _vc.dispose();
                this.containsElement(_vc) && removeElement(_vc);
                _vc = null;
            }

            _sizeInited = false;

            statusText && (statusText.text = "");

            _activeUser = null;
            _external = false;
            label = translate('label', 'screenshare');

            currentState = idle.name;
        }

        public function localize():void {

            if (!_activeUser)
                label = translate('label', 'screenshare');
            else
                label = translate('label', 'screenshare') + " — " + _activeUser.fullName;

            start_ext && (start_ext.label = translate('start_ext', 'screenshare'));
            stopshareBtn && (stopshareBtn.label = translate('stop_share', 'screenshare'));
            descExtTxt && (descExtTxt.text = translate('desc_ext', 'screenshare'));
            server_name && (server_name.text = translate('server_name', 'screenshare'));
            stream_name && (stream_name.text = translate('stream_name', 'screenshare'));
            cancel_ext && (cancel_ext.label = translate('Cancel'));
        }


        private function setVideoSize():void {

            if (!_sizeInited && _vc && _vc.width > 0 && _vc.videoWidth > 0) {
                _vc && _vc.setActualSize(_vc.width, _vc.height);
                _sizeInited = true;
                clearInterval(_sizeId);
            }

        }


        override public function set permissions(value:uint):void {

            super.permissions = value;

            _p_enabled = Permissions.docsAvailable(value);

            if (!_p_enabled && _activeUser && (_activeUser.sid === user.sid)) dispose();

        }


        override public function get settings():Vector.<SettingsItem> {
            return _settings;
        }
        ]]>
	</fx:Script>
    <s:Label id="statusText" horizontalCenter="0" excludeFrom="idle,sharing" verticalCenter="-60"/>

    <s:VGroup verticalCenter="0" horizontalCenter="0" includeIn="prepare,iampreparing">
        <s:BusyIndicator rotationInterval="50" symbolColor="0x71a7cd" width="60" height="60"/>
    </s:VGroup>

    <s:Group id="idleGroup" horizontalCenter="0" height="100%" includeIn="idle"
             visible="{_p_enabled}">
            <s:Group width="300" horizontalCenter="0" height="200" id="extGroup" verticalCenter="0">
               <components:CustomSkinableButton id="start_ext" width="220" click="startExternal()"
                                                     horizontalCenter="0"
                                                     skinClass="ru.teachbase.skins.StandartButton"
                                                     initialize="with(start_ext){label=translate('start_ext','screenshare');}"
                            />
                <s:RichText  y="50" id="descExtTxt" initialize="with(descExtTxt){text = translate('desc_ext','screenshare')}" width="100%"
                            textAlign="center" fontSize="13"/>
                <mx:LinkButton width="200"
                               y="90"
                               fontSize="14"
                               color="#007fe3"
                               horizontalCenter="0"
                               id="ext_help_link"
                               click="navigateToURL(new URLRequest(config('external_help_url')), '_blank')"
                               initialize="with(ext_help_link){ visible = !!config('external_help_url'); label = translate('ext_link', 'screenshare')}"/>

            </s:Group>
    </s:Group>
    <s:VGroup includeIn="prepare_ext" horizontalCenter="0" verticalCenter="0" width="350" height="200">
        <s:Label id="server_name" fontSize="13" textAlign="left" initialize="server_name.text=translate('server_name','screenshare');"/>
        <s:TextInput id="server_txt" height="31" width="100%" selectionHighlighting="whenFocused" selectable="true" textAlign="left" text="{ _external_path }">
             <s:click><![CDATA[
                 server_txt.selectAll();
                 System.setClipboard(server_txt.text);
                 ]]></s:click>
        </s:TextInput>
        <s:Label id="stream_name" fontSize="13" textAlign="left" initialize="stream_name.text=translate('stream_name','screenshare');"/>
        <s:TextInput id="stream_name_txt" height="31" width="100%" selectionHighlighting="whenFocused" selectable="true" textAlign="left" text="{ _external_name }">
           <s:click><![CDATA[
               stream_name_txt.selectAll();
               System.setClipboard(server_txt.text);
           ]]></s:click>
        </s:TextInput>
        <components:CustomSkinableButton id="cancel_ext" width="160"
                                         left="0"
                                         skinClass="ru.teachbase.skins.StandartButton"
                                         initialize="with(cancel_ext){label=translate('Cancel');}">
          <components:click><![CDATA[
              currentState = idle.name;
              ]]></components:click>
          </components:CustomSkinableButton>
    </s:VGroup>
    <s:Image source="{style('modulecontainer','bottomBackground')}" left="0" bottom="0" scaleMode="stretch" height="46"
             includeIn="iamsharing,iampreparing,iamexternal" width="100%"/>
    <s:Button includeIn="iamsharing,iampreparing,iamexternal" fontSize="13" id="stopshareBtn" width="214"
              initialize="stopshareBtn.label = translate('stop_share','screenshare');" fontWeight="normal"
              left="7" bottom="7" click="stopShare()"
              skinClass="ru.teachbase.module.screenshare.skins.StopShareButtonSkin"/>
</module:ModuleInstance>
